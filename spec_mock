require 'spec_helper'
require 'breakfast_app'
require 'json'
require 'benchmark'

RSpec.describe 'BreakfastApp' do
  subject(:result) { JSON.parse(BreakfastApp.call(price_list_json, orders_json)) }

  let(:price_list_json) do
    JSON.generate([
      { id: 'flat-white', name: 'Flat White', price: 3.0 },
      { id: 'espresso', name: 'Espresso', price: 2.0 },
      { id: 'bacon-egg-roll', name: 'Bacon & Egg Roll', price: 5.0 },
      { id: 'bbq-sauce', name: 'BBQ Sauce', price: 0.0 }
    ])
  end

  describe 'Core functionality' do
    let(:orders_json) do
      JSON.generate([
        { name: 'dave', money: 10.0, items: ['flat-white', 'bacon-egg-roll', 'bbq-sauce'] },
        { name: 'jenny', money: 5.0, items: ['espresso'] }
      ])
    end

    it 'calculates correct change' do
      expect(result).to contain_exactly(
        { 'name' => 'dave', 'change' => 2.0 },
        { 'name' => 'jenny', 'change' => 3.0 }
      )
    end
  end

  describe 'Edge cases' do
    it 'returns full money as change when no items' do
      orders_json = JSON.generate([{ name: 'empty', money: 5.0, items: [] }])
      res = JSON.parse(BreakfastApp.call(price_list_json, orders_json))
      expect(res.first['change']).to eq(5.0)
    end

    it 'returns 0 change for exact payment' do
      orders_json = JSON.generate([{ name: 'exact', money: 5.0, items: ['bacon-egg-roll'] }])
      res = JSON.parse(BreakfastApp.call(price_list_json, orders_json))
      expect(res.first['change']).to eq(0.0)
    end

    it 'returns negative change for underpayment' do
      orders_json = JSON.generate([{ name: 'under', money: 1.0, items: ['flat-white'] }])
      res = JSON.parse(BreakfastApp.call(price_list_json, orders_json))
      expect(res.first['change']).to eq(-2.0)
    end

    it 'handles duplicate items by summing cost' do
      orders_json = JSON.generate([{ name: 'double-shot', money: 10.0, items: ['espresso', 'espresso'] }])
      res = JSON.parse(BreakfastApp.call(price_list_json, orders_json))
      expect(res.first['change']).to eq(6.0)
    end
  end

  describe 'Invalid input handling' do
    it 'raises error for unknown item' do
      orders_json = JSON.generate([{ name: 'ghost', money: 5.0, items: ['unicorn-frappe'] }])
      expect { BreakfastApp.call(price_list_json, orders_json) }.to raise_error(StandardError)
    end

    it 'raises error for missing fields' do
      orders_json = JSON.generate([{ name: 'no-items', money: 5.0 }])
      expect { BreakfastApp.call(price_list_json, orders_json) }.to raise_error(StandardError)
    end

    it 'raises error for malformed JSON' do
      malformed_json = '[{ name: "bob", items: [espresso] ' # missing brackets and quotes
      expect { BreakfastApp.call(price_list_json, malformed_json) }.to raise_error(JSON::ParserError)
    end
  end

  describe 'Scalability and performance' do
    let(:orders_json) do
      orders = Array.new(1000) { |i| { name: "user#{i}", money: 10.0, items: ['espresso', 'flat-white'] } }
      JSON.generate(orders)
    end

    it 'handles large datasets correctly' do
      expect(result.size).to eq(1000)
      expect(result.first).to include('name', 'change')
    end

    it 'executes within reasonable time' do
      time = Benchmark.realtime { BreakfastApp.call(price_list_json, orders_json) }
      expect(time).to be < 2.0
    end
  end

  describe 'Special cases' do
    it 'allows duplicate user names' do
      orders_json = JSON.generate([
        { name: 'alex', money: 5.0, items: ['espresso'] },
        { name: 'alex', money: 6.0, items: ['flat-white'] }
      ])
      res = JSON.parse(BreakfastApp.call(price_list_json, orders_json))
      expect(res.count).to eq(2)
    end

    it 'handles item with zero price' do
      orders_json = JSON.generate([{ name: 'bbq', money: 2.0, items: ['bbq-sauce'] }])
      res = JSON.parse(BreakfastApp.call(price_list_json, orders_json))
      expect(res.first['change']).to eq(2.0)
    end

    it 'handles high-precision price calculation' do
      price_list = JSON.generate([{ id: 'weird-coffee', name: 'Weird Coffee', price: 2.3333 }])
      orders_json = JSON.generate([{ name: 'precision', money: 5.0, items: ['weird-coffee', 'weird-coffee'] }])
      res = JSON.parse(BreakfastApp.call(price_list, orders_json))
      expect(res.first['change']).to be_within(0.01).of(0.33)
    end
  end
end
